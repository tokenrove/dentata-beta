/* 
 * blitgen.c
 * Created: Mon Jan 29 13:42:41 2001 by tek@wiw.org
 * Revised: Sat Jun 23 04:12:31 2001 by tek@wiw.org
 * Copyright 2001 Julian E. C. Squires (tek@wiw.org)
 * This program comes with ABSOLUTELY NO WARRANTY.
 * $Id$
 *
 * There isn't a great deal of documentation on these fairly
 * terse functions. The best way to understand them is to read
 * the dentata gen beta manual on the subject of pixel packings
 * for various depths and alphas, before looking at the code.
 * (and remember:
 *         d = a*s + (1-a)*d
 *  d == dest, s == src, a == alpha)
 */

#include <dentata/types.h>
#include <dentata/memory.h>

#define max(a, b) (((a) > (b))?(a):(b))
#define min(a, b) (((a) > (b))?(b):(a))

/* _blit_onethird: 1/3 from 0 to 255. [autogenerated] */
static byte _blit_onethird[256] = {
    0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4,
    5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9,
    10, 10, 10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 14, 14, 14,
    15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19,
    20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24,
    25, 25, 25, 26, 26, 26, 27, 27, 27, 28, 28, 28, 29, 29, 29,
    30, 30, 30, 31, 31, 31, 32, 32, 32, 33, 33, 33, 34, 34, 34,
    35, 35, 35, 36, 36, 36, 37, 37, 37, 38, 38, 38, 39, 39, 39,
    40, 40, 40, 41, 41, 41, 42, 42, 42, 43, 43, 43, 44, 44, 44,
    45, 45, 45, 46, 46, 46, 47, 47, 47, 48, 48, 48, 49, 49, 49,
    50, 50, 50, 51, 51, 51, 52, 52, 52, 53, 53, 53, 54, 54, 54,
    55, 55, 55, 56, 56, 56, 57, 57, 57, 58, 58, 58, 59, 59, 59,
    60, 60, 60, 61, 61, 61, 62, 62, 62, 63, 63, 63, 64, 64, 64,
    65, 65, 65, 66, 66, 66, 67, 67, 67, 68, 68, 68, 69, 69, 69,
    70, 70, 70, 71, 71, 71, 72, 72, 72, 73, 73, 73, 74, 74, 74,
    75, 75, 75, 76, 76, 76, 77, 77, 77, 78, 78, 78, 79, 79, 79,
    80, 80, 80, 81, 81, 81, 82, 82, 82, 83, 83, 83, 84, 84, 84,
    85
};

/* _blit_twothird: 2/3 from 0 to 255. [autogenerated] */
static byte _blit_twothird[256] = {
    0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9,
    10, 10, 11, 12, 12, 13, 14, 14, 15, 16, 16, 17, 18, 18, 19,
    20, 20, 21, 22, 22, 23, 24, 24, 25, 26, 26, 27, 28, 28, 29,
    30, 30, 31, 32, 32, 33, 34, 34, 35, 36, 36, 37, 38, 38, 39,
    40, 40, 41, 42, 42, 43, 44, 44, 45, 46, 46, 47, 48, 48, 49,
    50, 50, 51, 52, 52, 53, 54, 54, 55, 56, 56, 57, 58, 58, 59,
    60, 60, 61, 62, 62, 63, 64, 64, 65, 66, 66, 67, 68, 68, 69,
    70, 70, 71, 72, 72, 73, 74, 74, 75, 76, 76, 77, 78, 78, 79,
    80, 80, 81, 82, 82, 83, 84, 84, 85, 86, 86, 87, 88, 88, 89,
    90, 90, 91, 92, 92, 93, 94, 94, 95, 96, 96, 97, 98, 98, 99,
    100, 100, 101, 102, 102, 103, 104, 104, 105, 106, 106, 107, 108, 108, 109,
    110, 110, 111, 112, 112, 113, 114, 114, 115, 116, 116, 117, 118, 118, 119,
    120, 120, 121, 122, 122, 123, 124, 124, 125, 126, 126, 127, 128, 128, 129,
    130, 130, 131, 132, 132, 133, 134, 134, 135, 136, 136, 137, 138, 138, 139,
    140, 140, 141, 142, 142, 143, 144, 144, 145, 146, 146, 147, 148, 148, 149,
    150, 150, 151, 152, 152, 153, 154, 154, 155, 156, 156, 157, 158, 158, 159,
    160, 160, 161, 162, 162, 163, 164, 164, 165, 166, 166, 167, 168, 168, 169,
    170
};

/*
 * 8 bpp
 */

void _blit80(byte *ddat, byte *dalp, byte *sdat, byte *salp, dword doffs,
             dword dscanoff, dword scanlen, dword endoffs, dword soffs,
             dword sscanoff);

void _blit80(byte *ddat, byte *dalp, byte *sdat, byte *salp, dword doffs,
             dword dscanoff, dword scanlen, dword endoffs, dword soffs,
             dword sscanoff)
{
    register byte *end;
    register dword a, b;

    end = ddat+endoffs;
    ddat += doffs;
    sdat += soffs;
    a = scanlen+dscanoff;
    b = scanlen+sscanoff;
    do {
        d_memory_copy(ddat, sdat, scanlen);
        ddat += a;
        sdat += b;
    } while(ddat < end);
    return;
}

void _blit81(byte *ddat, byte *dalp, byte *sdat, byte *salp, dword doffs,
             dword dscanoff, dword scanlen, dword endoffs, dword soffs,
             dword sscanoff)
{
    register dword i;
    register byte *end;

    end = ddat+endoffs;
    ddat += doffs;
    sdat += soffs;

    do {
        for(i = scanlen; i > 0; i--) {
            if(*sdat)
                *(ddat++) = *(sdat++);
            else {
                ddat++;
                sdat++;
            }
        }
        ddat += dscanoff;
        sdat += sscanoff;
    } while(ddat < end);
    return;
}

/*
 * 16 bpp
 */

void _blit160(byte *ddat, byte *dalp, byte *sdat, byte *salp, dword doffs,
              dword dscanoff, dword scanlen, dword endoffs, dword soffs,
              dword sscanoff);
void _blit161(byte *ddat, byte *dalp, byte *sdat, byte *salp, dword doffs,
              dword dscanoff, dword scanlen, dword endoffs, dword soffs,
              dword sscanoff);
void _blit162(byte *ddat, byte *dalp, byte *sdat, byte *salp, dword doffs,
              dword dscanoff, dword scanlen, dword endoffs, dword soffs,
              dword sscanoff);
void _blit164(byte *ddat, byte *dalp, byte *sdat, byte *salp, dword doffs,
              dword dscanoff, dword scanlen, dword endoffs, dword soffs,
              dword sscanoff);
void _blit168(byte *ddat, byte *dalp, byte *sdat, byte *salp, dword doffs,
              dword dscanoff, dword scanlen, dword endoffs, dword soffs,
              dword sscanoff);

void _blit160(byte *ddat, byte *dalp, byte *sdat, byte *salp, dword doffs,
              dword dscanoff, dword scanlen, dword endoffs, dword soffs,
              dword sscanoff)
{
    byte *end;

    end = ddat+(endoffs*2);
    ddat += doffs*2;
    sdat += soffs*2;

    do {
        d_memory_copy(ddat, sdat, scanlen*2);
        ddat += (scanlen+dscanoff)*2;
        sdat += (scanlen+sscanoff)*2;
    } while(ddat < end);
    return;
}

void _blit161(byte *ddat, byte *dalp, byte *sdat, byte *salp, dword doffs,
              dword dscanoff, dword scanlen, dword endoffs, dword soffs,
              dword sscanoff)
{
    register dword i;
    register byte j;
    byte *end;

    end = ddat+endoffs*2;
    ddat += doffs*2;
    sdat += soffs*2;

    j = soffs&7;
    salp += soffs>>3;

    do {
        for(i = scanlen; i > 0; i--) {
            if((*salp)&(1<<j)) {
                *(ddat++) = *(sdat++);
                *(ddat++) = *(sdat++);
            } else {
                ddat += 2;
                sdat += 2;
            }
            j++;
            if(j == 8) {
                j = 0;
                salp++;
            }
        }
        ddat += dscanoff*2;
        sdat += sscanoff*2;
        salp += sscanoff>>3;
        j += sscanoff&7;
        if(j > 7) {
            salp++;
            j &= 7;
        }
    } while(ddat < end);
    return;
}

/* Uses table lookup to avoid costly divides (see _blit_onethird and
 * _blit_twothird tables at the top of this file). The tables were generated
 * using gendivtables by tek. (this note also applies to _blit242) */
void _blit162(byte *ddat, byte *dalp, byte *sdat, byte *salp, dword doffs,
              dword dscanoff, dword scanlen, dword endoffs, dword soffs,
              dword sscanoff)
{
    register dword i;
    register byte j;
    register word k, l;
    byte *end;
    byte masktable[4] = { 3, 15, 63, 255 };

    end = ddat+endoffs*2;
    ddat += doffs*2;
    sdat += soffs*2;

    j = soffs&3;
    salp += soffs>>2;

    do {
        for(i = scanlen; i > 0; i--) {
            switch(((*salp)&masktable[j])>>(2*j)) {
            case 0:
                ddat += 2;
                sdat += 2;
                break;

            case 1:
                k = (*sdat)&31;
                k = _blit_onethird[k];
                k += _blit_twothird[((*ddat)&31)];
                l = (*(sdat++))>>5; l |= ((*sdat)&7)<<3;
                l = _blit_onethird[l];
                l += _blit_twothird[(((*ddat)>>5)|(((*(ddat+1))&7)<<3))];
                *(ddat++) = k|((l&7)<<5);
                k = (*(sdat++))>>3;
                k = _blit_onethird[k];
                k += _blit_twothird[(*ddat)>>3];
                *(ddat++) = (k<<3)|(l>>3);
                break;

            case 2:
                k = (*sdat)&31;
                k = _blit_twothird[k];
                k += _blit_onethird[(*ddat)&31];
                l = (*(sdat++))>>5; l |= ((*sdat)&7)<<3;
                l = _blit_twothird[l];
                l += _blit_onethird[((*ddat)>>5)|(((*(ddat+1))&7)<<3)];
                *(ddat++) = k|((l&7)<<5);
                k = (*(sdat++))>>3;
                k = _blit_twothird[k];
                k += _blit_onethird[(*ddat)>>3];
                *(ddat++) = (k<<3)|(l>>3);
                break;

            case 3:
                *(ddat++) = *(sdat++);
                *(ddat++) = *(sdat++);
                break;
            }
            j++;
            if(j == 4) {
                j = 0;
                salp++;
            }
        }
        ddat += dscanoff*2;
        sdat += sscanoff*2;
        salp += sscanoff>>2;
        j += sscanoff&3;
        if(j > 3) {
            salp++;
            j &= 3;
        }
    } while(ddat < end);
    return;
}

void _blit164(byte *ddat, byte *dalp, byte *sdat, byte *salp, dword doffs,
              dword dscanoff, dword scanlen, dword endoffs, dword soffs,
              dword sscanoff)
{
    register int i;
    register word j, k;
    register byte l, a;
    byte *end;

    end = ddat+endoffs*2;
    ddat += doffs*2;
    sdat += soffs*2;
    salp += soffs>>1;
    l = soffs&1;

    do {
        for(i = scanlen; i > 0; i--) {
            if(l == 0)
                a = (*salp)&0x0f;
            else
                a = (*(salp++))>>4;
            a++;

            j = (((*sdat)&31)*a)>>4;
            j += (((*ddat)&31)*(17-a))>>4;
            k = (*(sdat++))>>5; k |= ((*sdat)&7)<<3;
            k = (k*a)>>4;
            k += ((((*ddat)>>5)|(((*(ddat+1))&7)<<3))*(17-a))>>4;
            *(ddat++) = j|((k&7)<<5);
            j = (*(sdat++))>>3;
            j = (j*a)>>4;
            j += (((*ddat)>>3)*(17-a))>>4;
            *(ddat++) = (j<<3)|(k>>3);

            l = (l+1)&1;
        }
        ddat += dscanoff*2;
        sdat += sscanoff*2;
        salp += sscanoff>>1;
        l += sscanoff&1;
        if(l > 1) {
            l = 0;
            salp++;
        }
    } while(ddat < end);
    return;
}

/* The math in this function may seem a bit odd (adding one to the alpha,
 * subtracting from 257), but it seems to work. At least the calculations
 * came out correct for me (tek) when I did some quick math on paper. It
 * allows us to use shifts instead of divides (which are _insanely_ costly
 * on a lot of platforms). */
void _blit168(byte *ddat, byte *dalp, byte *sdat, byte *salp, dword doffs,
              dword dscanoff, dword scanlen, dword endoffs, dword soffs,
              dword sscanoff)
{
    register dword i;
    register word j, k, a;
    byte *end;

    end = ddat+endoffs*2;
    ddat += doffs*2;
    sdat += soffs*2;
    salp += soffs;

    do {
        for(i = scanlen; i > 0; i--) {
            a = *salp;
            a++;
            j = (*sdat)&31;
            j = (j*a)>>8;
            j += (((*ddat)&31)*(257-a))>>8;
            k = (*(sdat++))>>5; k |= ((*sdat)&7)<<3;
            k = (k*a)>>8;
            k += ((((*ddat)>>5)|(((*(ddat+1))&7)<<3))*(257-a))>>8;
            *(ddat++) = j|((k&7)<<5);
            j = (*(sdat++))>>3;
            j = (j*a)>>8;
            j += (((*ddat)>>3)*(257-a))>>8;
            *(ddat++) = (j<<3)|(k>>3);
            salp++;
        }
        ddat += dscanoff*2;
        sdat += sscanoff*2;
        salp += sscanoff;
    } while(ddat < end);

    return;
}

/*
 * 24 bpp
 */

void _blit240(byte *ddat, byte *dalp, byte *sdat, byte *salp, dword doffs,
              dword dscanoff, dword scanlen, dword endoffs, dword soffs,
              dword sscanoff)
{
    register dword i;
    byte *end;

    end = ddat+endoffs*3;
    ddat += doffs*3;
    sdat += soffs*3;

    do {
        for(i = scanlen; i > 0; i--) {
            *(ddat++) = *(sdat++);
            *(ddat++) = *(sdat++);
            *(ddat++) = *(sdat++);
        }
        ddat += dscanoff*3;
        sdat += sscanoff*3;
    } while(ddat < end);
    return;
}

void _blit241(byte *ddat, byte *dalp, byte *sdat, byte *salp, dword doffs,
              dword dscanoff, dword scanlen, dword endoffs, dword soffs,
              dword sscanoff)
{
    register dword i;
    register byte j;
    byte *end;

    end = ddat+endoffs*3;
    ddat += doffs*3;
    sdat += soffs*3;

    j = soffs&7;
    salp += soffs>>3;

    do {
        for(i = scanlen; i > 0; i--) {
            if((*salp)&(1<<j)) {
                *(ddat++) = *(sdat++);
                *(ddat++) = *(sdat++);
                *(ddat++) = *(sdat++);
            } else {
                ddat += 3;
                sdat += 3;
            }
            j++;
            if(j == 8) {
                j = 0;
                salp++;
            }
        }
        ddat += dscanoff*3;
        sdat += sscanoff*3;
        salp += sscanoff>>3;
        j += sscanoff&7;
        if(j > 7) {
            salp++;
            j &= 7;
        }
    } while(ddat < end);
    return;
}

/* The notes which apply to _blit162 also apply here. */
void _blit242(byte *ddat, byte *dalp, byte *sdat, byte *salp, dword doffs,
              dword dscanoff, dword scanlen, dword endoffs, dword soffs,
              dword sscanoff)
{
    register dword i;
    register byte j;
    byte *end;
    byte masktable[4] = { 3, 15, 63, 255 };

    end = ddat+endoffs*3;
    ddat += doffs*3;
    sdat += soffs*3;

    j = soffs&3;
    salp += soffs>>2;

    do {
        for(i = scanlen; i > 0; i--) {
            switch(((*salp)&masktable[j])>>(2*j)) {
            case 0:
                ddat += 3;
                sdat += 3;
                break;

            case 1:
                *(ddat++) = _blit_onethird[*(sdat++)]+_blit_twothird[*ddat];
                *(ddat++) = _blit_onethird[*(sdat++)]+_blit_twothird[*ddat];
                *(ddat++) = _blit_onethird[*(sdat++)]+_blit_twothird[*ddat];
                break;

            case 2:
                *(ddat++) = _blit_twothird[*(sdat++)]+_blit_onethird[*ddat];
                *(ddat++) = _blit_twothird[*(sdat++)]+_blit_onethird[*ddat];
                *(ddat++) = _blit_twothird[*(sdat++)]+_blit_onethird[*ddat];
                break;

            case 3:
                *(ddat++) = *(sdat++);
                *(ddat++) = *(sdat++);
                *(ddat++) = *(sdat++);
                break;
            }
            j++;
            if(j == 4) {
                j = 0;
                salp++;
            }
        }
        ddat += dscanoff*3;
        sdat += sscanoff*3;
        salp += sscanoff>>2;
        j += sscanoff&3;
        if(j > 3) {
            salp++;
            j &= 3;
        }
    } while(ddat < end);
    return;
}

void _blit244(byte *ddat, byte *dalp, byte *sdat, byte *salp, dword doffs,
              dword dscanoff, dword scanlen, dword endoffs, dword soffs,
              dword sscanoff)
{
    register int i;
    register word j;
    register byte l, a;
    byte *end;

    end = ddat+endoffs*3;
    ddat += doffs*3;
    sdat += soffs*3;
    salp += soffs/2;
    l = soffs%2;

    do {
        for(i = scanlen; i > 0; i--) {
            if(l == 0)
                a = (*salp)&0x0f;
            else
                a = (*(salp++))>>4;

            j = *(sdat++)*a/15;
            j += *ddat*(15-a)/15;
            *(ddat++) = j;
            j = *(sdat++)*a/15;
            j += *ddat*(15-a)/15;
            *(ddat++) = j;
            j = *(sdat++)*a/15;
            j += *ddat*(15-a)/15;
            *(ddat++) = j;

            l = (l+1)%2;
        }
        ddat += dscanoff*3;
        sdat += sscanoff*3;
        salp += sscanoff/2;
        l += sscanoff%2;
        if(l > 1) {
            l = 0;
            salp++;
        }
    } while(ddat < end);
    return;
}

/* See the note above _blit168 about the technique used here. */
void _blit248(byte *ddat, byte *dalp, byte *sdat, byte *salp, dword doffs,
              dword dscanoff, dword scanlen, dword endoffs, dword soffs,
              dword sscanoff)
{
    register int i;
    register word j, a;
    byte *end;

    end = ddat+endoffs*3;
    ddat += doffs*3;
    sdat += soffs*3;
    salp += soffs;

    do {
        for(i = scanlen; i > 0; i--) {
            a = *salp+1;
            j = (*(sdat++)*a)>>8;
            j += (*ddat*(257-a))>>8;
            *(ddat++) = j;
            j = (*(sdat++)*a)>>8;
            j += (*ddat*(257-a))>>8;
            *(ddat++) = j;
            j = (*(sdat++)*a)>>8;
            j += (*ddat*(257-a))>>8;
            *(ddat++) = j;
            salp++;
        }
        ddat += dscanoff*3;
        sdat += sscanoff*3;
        salp += sscanoff;
    } while(ddat < end);
    return;
}

/* EOF blitgen.c */
